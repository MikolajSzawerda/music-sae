#!/usr/bin/env python3
"""
Intervention Results Plotting Script

This script creates box plots from individual scores generated by evaluate_interventions.py
to compare different algorithms, features, or combinations.

Usage:
    python plot_intervention_results.py individual_scores.json --split-by algorithm
    python plot_intervention_results.py individual_scores.json --split-by feature --filter-algorithm intervention_zero_ablate
"""

import argparse
import json
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional
from collections import defaultdict

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Set style
plt.style.use("default")
sns.set_palette("husl")


def load_individual_scores(file_path: Path) -> tuple[List[Dict[str, Any]], Dict[str, Any]]:
    """Load individual scores from JSON file."""
    with open(file_path, "r") as f:
        data = json.load(f)

    if "individual_scores" in data:
        scores = data["individual_scores"]
        run_info = data.get("run_info", {})
        return scores, run_info
    else:
        # Assume the file contains scores directly
        return data, {}


def load_multiple_runs(file_paths: List[Path]) -> List[Dict[str, Any]]:
    """Load and combine individual scores from multiple runs."""
    all_scores = []

    for file_path in file_paths:
        logger.info(f"Loading scores from: {file_path}")
        scores, run_info = load_individual_scores(file_path)

        # Extract run parameters from execution_params
        execution_params = run_info.get("execution_params", {})
        run_algorithm = execution_params.get("algorithm", "unknown")
        run_intervention_value = execution_params.get("intervention_value", 0.0)
        run_intervention_frequency = execution_params.get("intervention_frequency", 1)
        run_id = execution_params.get("run_id", str(file_path.stem))

        # Add run-level metadata to each score
        for score in scores:
            enhanced_score = score.copy()
            enhanced_score.update(
                {
                    "run_id": run_id,
                    "run_algorithm": run_algorithm,
                    "run_intervention_value": run_intervention_value,
                    "run_intervention_frequency": run_intervention_frequency,
                    "run_file": str(file_path),
                }
            )
            all_scores.append(enhanced_score)

        logger.info(f"Loaded {len(scores)} scores from {file_path.name}")

    logger.info(f"Combined total: {len(all_scores)} scores from {len(file_paths)} runs")
    return all_scores


def filter_scores(
    scores: List[Dict[str, Any]],
    filter_algorithm: Optional[str] = None,
    filter_feature: Optional[str] = None,
    filter_prompt_contains: Optional[str] = None,
    filter_run_algorithm: Optional[str] = None,
    filter_run_intervention_value: Optional[float] = None,
    filter_run_intervention_frequency: Optional[int] = None,
    filter_run_id: Optional[str] = None,
) -> List[Dict[str, Any]]:
    """Filter scores based on criteria."""
    filtered = scores

    if filter_algorithm:
        filtered = [s for s in filtered if s["algorithm"] == filter_algorithm]

    if filter_feature:
        filtered = [s for s in filtered if s["feature"] == filter_feature]

    if filter_prompt_contains:
        filtered = [s for s in filtered if filter_prompt_contains.lower() in s["prompt"].lower()]

    if filter_run_algorithm:
        filtered = [s for s in filtered if s.get("run_algorithm") == filter_run_algorithm]

    if filter_run_intervention_value is not None:
        filtered = [s for s in filtered if s.get("run_intervention_value") == filter_run_intervention_value]

    if filter_run_intervention_frequency is not None:
        filtered = [s for s in filtered if s.get("run_intervention_frequency") == filter_run_intervention_frequency]

    if filter_run_id:
        filtered = [s for s in filtered if filter_run_id in s.get("run_id", "")]

    return filtered


def create_algorithm_label_with_params(score: Dict[str, Any]) -> str:
    """Create algorithm labels with intervention parameters for intervention algorithms."""
    algorithm = score.get("algorithm", "unknown")

    # If it's an intervention algorithm, add parameters
    if algorithm.startswith("intervention_"):
        run_value = score.get("run_intervention_value", 0.0)
        run_freq = score.get("run_intervention_frequency", 1)
        base_algo = algorithm.replace("intervention_", "")
        return f"{base_algo} (val={run_value}, freq={run_freq})"
    else:
        # For non-intervention algorithms (musicgen, sae_passthrough), keep simple
        return algorithm


def create_compound_label(score: Dict[str, Any], split_by: str) -> str:
    """Create compound labels for run parameters."""
    if split_by == "algorithm":
        # Enhanced algorithm labels with parameters
        return create_algorithm_label_with_params(score)
    elif split_by == "run_intervention_value":
        return f"val={score.get('run_intervention_value', 'unknown')}"
    elif split_by == "run_intervention_frequency":
        return f"freq={score.get('run_intervention_frequency', 'unknown')}"
    elif split_by == "run_algorithm":
        return f"{score.get('run_algorithm', 'unknown')}"
    elif split_by == "run_id":
        # Shorten run_id for display
        run_id = score.get("run_id", "unknown")
        if len(run_id) > 20:
            return run_id[:17] + "..."
        return run_id
    else:
        return str(score.get(split_by, "unknown"))


def create_box_plot(
    scores: List[Dict[str, Any]],
    split_by: str,
    title: str = None,
    ylabel: str = "CLAP Score",
    figsize: tuple = (12, 8),
    rotation: int = 45,
    save_path: Optional[Path] = None,
):
    """Create box plot comparing groups."""

    # Prepare data for plotting
    data_dict = defaultdict(list)

    for score in scores:
        if split_by.startswith("run_") or split_by == "algorithm":
            group_key = create_compound_label(score, split_by)
        else:
            group_key = score[split_by]
        data_dict[group_key].append(score["clap_score"])

    # Convert to lists for plotting
    groups = list(data_dict.keys())
    values = [data_dict[group] for group in groups]

    # Create figure
    plt.figure(figsize=figsize)

    # Create box plot
    box_plot = plt.boxplot(values, labels=groups, patch_artist=True)

    # Color the boxes
    colors = sns.color_palette("husl", len(groups))
    for patch, color in zip(box_plot["boxes"], colors):
        patch.set_facecolor(color)
        patch.set_alpha(0.7)

    # Customize plot
    plt.ylabel(ylabel, fontsize=12)
    plt.xlabel(split_by.replace("_", " ").title(), fontsize=12)

    if title:
        plt.title(title, fontsize=14, fontweight="bold")

    plt.xticks(rotation=rotation)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()

    # Add statistics annotations
    for i, (group, vals) in enumerate(zip(groups, values)):
        mean_val = np.mean(vals)
        plt.text(
            i + 1,
            mean_val,
            f"Î¼={mean_val:.3f}",
            ha="center",
            va="bottom",
            fontsize=8,
            bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.8),
        )

    # Save or show
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches="tight")
        logger.info(f"Plot saved to: {save_path}")
    else:
        plt.show()

    plt.close()


def create_seaborn_box_plot(
    scores: List[Dict[str, Any]],
    split_by: str,
    hue_by: Optional[str] = None,
    title: str = None,
    ylabel: str = "CLAP Score",
    figsize: tuple = (12, 8),
    save_path: Optional[Path] = None,
):
    """Create box plot using seaborn for more advanced features."""

    # Convert to DataFrame and add enhanced labels
    df_data = []
    for score in scores:
        enhanced_score = score.copy()

        # Add enhanced algorithm label
        if split_by == "algorithm" or (hue_by and hue_by == "algorithm"):
            enhanced_score["algorithm_enhanced"] = create_algorithm_label_with_params(score)

        # Add other enhanced labels as needed
        if split_by.startswith("run_") or split_by == "algorithm":
            enhanced_score[f"{split_by}_enhanced"] = create_compound_label(score, split_by)

        if hue_by and (hue_by.startswith("run_") or hue_by == "algorithm"):
            enhanced_score[f"{hue_by}_enhanced"] = create_compound_label(score, hue_by)

        df_data.append(enhanced_score)

    df = pd.DataFrame(df_data)

    # Use enhanced columns for plotting
    plot_split_by = f"{split_by}_enhanced" if (split_by.startswith("run_") or split_by == "algorithm") else split_by
    plot_hue_by = f"{hue_by}_enhanced" if (hue_by and (hue_by.startswith("run_") or hue_by == "algorithm")) else hue_by

    # Create figure
    plt.figure(figsize=figsize)

    # Create box plot with optional hue
    if plot_hue_by and plot_hue_by in df.columns:
        sns.boxplot(data=df, x=plot_split_by, y="clap_score", hue=plot_hue_by)
        plt.legend(bbox_to_anchor=(1.05, 1), loc="upper left")
    else:
        sns.boxplot(data=df, x=plot_split_by, y="clap_score")

    # Customize plot
    plt.ylabel(ylabel, fontsize=12)
    plt.xlabel(split_by.replace("_", " ").title(), fontsize=12)

    if title:
        plt.title(title, fontsize=14, fontweight="bold")

    plt.xticks(rotation=45)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()

    # Save or show
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches="tight")
        logger.info(f"Plot saved to: {save_path}")
    else:
        plt.show()

    plt.close()


def create_violin_plot(
    scores: List[Dict[str, Any]],
    split_by: str,
    title: str = None,
    ylabel: str = "CLAP Score",
    figsize: tuple = (12, 8),
    save_path: Optional[Path] = None,
):
    """Create violin plot showing full distribution."""

    # Convert to DataFrame and add enhanced labels
    df_data = []
    for score in scores:
        enhanced_score = score.copy()

        # Add enhanced labels as needed
        if split_by.startswith("run_") or split_by == "algorithm":
            enhanced_score[f"{split_by}_enhanced"] = create_compound_label(score, split_by)

        df_data.append(enhanced_score)

    df = pd.DataFrame(df_data)

    # Use enhanced column for plotting
    plot_split_by = f"{split_by}_enhanced" if (split_by.startswith("run_") or split_by == "algorithm") else split_by

    # Create figure
    plt.figure(figsize=figsize)

    # Create violin plot
    sns.violinplot(data=df, x=plot_split_by, y="clap_score")

    # Customize plot
    plt.ylabel(ylabel, fontsize=12)
    plt.xlabel(split_by.replace("_", " ").title(), fontsize=12)

    if title:
        plt.title(title, fontsize=14, fontweight="bold")

    plt.xticks(rotation=45)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()

    # Save or show
    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches="tight")
        logger.info(f"Plot saved to: {save_path}")
    else:
        plt.show()

    plt.close()


def print_summary_stats(scores: List[Dict[str, Any]], split_by: str):
    """Print summary statistics for each group."""
    print(f"\n{'=' * 60}")
    print(f"SUMMARY STATISTICS BY {split_by.upper()}")
    print("=" * 60)

    # Group data
    data_dict = defaultdict(list)
    for score in scores:
        group_key = score[split_by]
        data_dict[group_key].append(score["clap_score"])

    # Print stats for each group
    for group, values in sorted(data_dict.items()):
        values = np.array(values)
        print(f"\n{group}:")
        print(f"  Count: {len(values)}")
        print(f"  Mean:  {np.mean(values):.4f}")
        print(f"  Std:   {np.std(values):.4f}")
        print(f"  Min:   {np.min(values):.4f}")
        print(f"  Max:   {np.max(values):.4f}")
        print(f"  Q1:    {np.percentile(values, 25):.4f}")
        print(f"  Q3:    {np.percentile(values, 75):.4f}")


def main():
    parser = argparse.ArgumentParser(description="Create box plots from intervention evaluation results")
    parser.add_argument(
        "scores_files",
        nargs="+",
        type=Path,
        help="One or more JSON files with individual scores from evaluate_interventions.py",
    )
    parser.add_argument(
        "--split-by",
        choices=[
            "algorithm",
            "feature",
            "prompt",
            "run_algorithm",
            "run_intervention_value",
            "run_intervention_frequency",
            "run_id",
        ],
        default="algorithm",
        help="How to group the data (default: algorithm)",
    )
    parser.add_argument(
        "--hue-by",
        choices=[
            "algorithm",
            "feature",
            "prompt",
            "run_algorithm",
            "run_intervention_value",
            "run_intervention_frequency",
            "run_id",
        ],
        help="Secondary grouping for seaborn plot (creates nested groups)",
    )
    parser.add_argument(
        "--plot-type",
        choices=["box", "violin", "seaborn"],
        default="seaborn",
        help="Type of plot to create (default: seaborn)",
    )
    parser.add_argument(
        "--filter-algorithm", help="Filter to specific algorithm (e.g., 'musicgen', 'intervention_zero_ablate')"
    )
    parser.add_argument("--filter-feature", help="Filter to specific feature (e.g., 'f0437')")
    parser.add_argument("--filter-prompt-contains", help="Filter to prompts containing specific text")
    parser.add_argument(
        "--filter-run-algorithm", help="Filter to specific run algorithm (e.g., 'zero_ablate', 'amplify')"
    )
    parser.add_argument("--filter-run-intervention-value", type=float, help="Filter to specific intervention value")
    parser.add_argument(
        "--filter-run-intervention-frequency", type=int, help="Filter to specific intervention frequency"
    )
    parser.add_argument("--filter-run-id", help="Filter to runs containing specific text in run_id")
    parser.add_argument("--title", help="Custom title for the plot")
    parser.add_argument("--output", type=Path, help="Save plot to file instead of displaying")
    parser.add_argument(
        "--figsize", nargs=2, type=int, default=[12, 8], help="Figure size as width height (default: 12 8)"
    )
    parser.add_argument("--show-stats", action="store_true", help="Print summary statistics")

    args = parser.parse_args()

    # Validate input files
    for scores_file in args.scores_files:
        if not scores_file.exists():
            raise FileNotFoundError(f"Scores file not found: {scores_file}")

    # Load data
    if len(args.scores_files) == 1:
        # Single file - maintain backward compatibility
        logger.info(f"Loading scores from: {args.scores_files[0]}")
        scores, _ = load_individual_scores(args.scores_files[0])
        logger.info(f"Loaded {len(scores)} individual scores")
    else:
        # Multiple files - combine them
        scores = load_multiple_runs(args.scores_files)

    # Apply filters
    original_count = len(scores)
    scores = filter_scores(
        scores,
        filter_algorithm=args.filter_algorithm,
        filter_feature=args.filter_feature,
        filter_prompt_contains=args.filter_prompt_contains,
        filter_run_algorithm=args.filter_run_algorithm,
        filter_run_intervention_value=args.filter_run_intervention_value,
        filter_run_intervention_frequency=args.filter_run_intervention_frequency,
        filter_run_id=args.filter_run_id,
    )

    if len(scores) < original_count:
        logger.info(f"Filtered to {len(scores)} scores (removed {original_count - len(scores)})")

    if len(scores) == 0:
        logger.error("No scores remaining after filtering")
        return

    # Generate title
    title = args.title
    if not title:
        title_parts = [f"CLAP Scores by {args.split_by.title()}"]
        if args.filter_algorithm:
            title_parts.append(f"(Algorithm: {args.filter_algorithm})")
        if args.filter_feature:
            title_parts.append(f"(Feature: {args.filter_feature})")
        title = " ".join(title_parts)

    # Print summary statistics if requested
    if args.show_stats:
        print_summary_stats(scores, args.split_by)

    # Create plot
    figsize = tuple(args.figsize)

    if args.plot_type == "box":
        create_box_plot(scores, args.split_by, title=title, figsize=figsize, save_path=args.output)
    elif args.plot_type == "violin":
        create_violin_plot(scores, args.split_by, title=title, figsize=figsize, save_path=args.output)
    else:  # seaborn
        create_seaborn_box_plot(
            scores, args.split_by, hue_by=args.hue_by, title=title, figsize=figsize, save_path=args.output
        )

    logger.info("Plotting complete!")


if __name__ == "__main__":
    main()
